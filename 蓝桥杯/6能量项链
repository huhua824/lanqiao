题目描述
在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有 N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标 记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗 能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为m*r*n（Mars单位），新产生的珠子的头标记为m， 尾标记为n。
需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。
例如：设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号◎表示两颗珠子的聚合操作，(j◎k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：
(4◎1)=10*2*3=60。
这一串项链可以得到最优值的一个聚合顺序所释放的总能量为
((4◎1)◎2)◎3）=10*2*3+10*3*5+10*5*10=710。

输入
第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行 是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当i〈N时，第i颗珠子的尾标记应该等于第i+1颗 珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。
至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。

输出
只有一行，是一个正整数E（E≤2.1*10^9），为一个最优聚合顺序所释放的总能量

样例输入
4
2 3 5 10
样例输出
710

代码：
public class Main{
	public static void main(String[] args) {
		Scanner input=new Scanner(System.in);
		int n=input.nextInt();
		int a[]=new int[n];
		//创建一维数组
		for(int i=0;i<n;i++) {
			a[i]=input.nextInt();
		}
		int b[][]=new int[n][2];
		//建立二维数组b，让b成为头接尾的n组
		for(int i=0;i<n;i++) {
			for(int j=0;j<2;j++) {
				if(j==1&&i==n-1) {
					b[i][j]=a[0]; //数组b的最后一个数字回到最开始的那个
					break;
				}
				b[i][j]=a[i+j];
			}
		}
		//a数组排序
		for(int i=0;i<n-1;i++) {
			for(int j=i;j<n;j++) {
				int temp;
				if(a[i]>a[j]) {
					temp=a[i];
					a[i]=a[j];
					a[j]=temp;
					}
				}
		}
		
		int x = 0,y = 0,sum=0;
		for(int i=0;i<n-1;i++) {
			for(int j=0;j<n;j++) {
				//查询头标跟数组a相等的下标
				if(b[j][0]==a[i]) {
					x=j;
				}
				//查询尾标跟数组a相等的下标
				if(b[j][1]==a[i]) {
					y=j;
				}
			}
			sum+=b[x][0]*b[x][1]*b[y][0];//计算能量
			b[x][0]=b[y][0]; //吞掉最小的数
			b[y][0]=b[y][1]=0;//清除剩下的一组
		}
		System.out.println(sum);
	}
}
